# 数据驱动

## new Vue发生了什么

Vue实际上是一个**类**，类在js中用Function实现，源码在**`src/core/instance/index.js`**

```typescript
function Vue(options) {
  if (__DEV__ && !(this instanceof Vue)) {
      //Vue只能通过new关键字初始化
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
    //调用 init() 方法
  this._init(options)
}
```

 `this._init` 方法在 **`src/core/instance/init.js`** 中定义

```typescript
// src/core/instance/init.js
import config from '../config'
import { initProxy } from './proxy'
import { initState } from './state'
import { initRender } from './render'
import { initEvents } from './events'
import { mark, measure } from '../util/perf'
import { initLifecycle, callHook } from './lifecycle'
import { initProvide, initInjections } from './inject'
import { extend, mergeOptions, formatComponentName } from '../util/index'
import type { Component } from 'types/component'
import type { InternalComponentOptions } from 'types/options'
import { EffectScope } from 'v3/reactivity/effectScope'

let uid = 0

export function initMixin(Vue: typeof Component) {
  //init方法的定义
  Vue.prototype._init = function (options?: Record<string, any>) {
    // 将当前组件实例赋值给 vm，可以方便地在组件中使用该实例进行操作
    const vm: Component = this
    // a uid
    vm._uid = uid++
    // 开始和结束标签，辅助生成AST（抽象语法树），有助于编译过程
    let startTag, endTag
    // 注释用于指导测试覆盖率工具 Istanbul 在统计代码覆盖率时如何处理该行代码
    // 用于过滤掉一些不能（或不需要）被测试到的代码分支，以避免代码覆盖率统计出现误差
    // 这段代码用于性能检测和调试
    /* istanbul ignore if */
    if (__DEV__ && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      // 将一个名为vue-perf-start:${vm._uid}的性能计数器标记设置为当前时间戳，用于测试性能
      mark(startTag)
    }

    // a flag to mark this as a Vue instance without having to do instanceof
    // check
    // 该属性用于区分普通js对象和Vue实例的标志，确保只有Vue实例上的数据属性才会被劫持
    vm._isVue = true
    // 用于跳过某些指定属性的响应式处理的属性，在响应式机制中，当我们给一个数据对象添加一个新的属性时，该属性默认不具备响应式
    // 也就是说，当该属性发生改变时，视图不会自动更新
    // avoid instances from being observed
    vm.__v_skip = true
      
    // 响应式作用域是Vue.js 3.x版本中引入的一种新特性，允许我们在组件或自定义hook内部创建一个独立的作用域环境，用于精确地控制响应式更新的粒度和时机。
    // 创建了一个新的响应式作用域实例，并指定了detached参数为true，表示该作用域是一个解除挂载的作用域，即在该作用域内部创建的响应函数不会被直接安装在Vue组件中，而是可以手动调用run方法进行懒执行。然后，将该作用域实例赋值给vm._scope属性，表示将该作用域与当前的Vue实例进行绑定。这样，在Vue组件内部就可以使用该作用域来处理响应式更新相关的操作。
    // effect scope
    vm._scope = new EffectScope(true /* detached */)
    // 标记该作用域已经被绑定到了一个Vue组件实例上
    vm._scope._vm = true
    // 用于初始化Vue组件实例的选项对象。组件的选项对象决定了组件的行为和模板渲染规则。
    // merge options
    if (options && options._isComponent) {
      // 表示该组件实例是一个内部组件，这里通过调用initInternalComponent方法来完成内部组件的初始化过程
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options as any)
    } else {
      // 不是内部组件，则将构造函数选项与传入的options对象进行合并，并将合并后的选项对象赋值给vm.$options属性
      vm.$options = mergeOptions(
        // 用于获取组件构造函数的选项对象，即在组件定义时所声明的选项，例如data、computed、methods等
        // mergeOptions()方法用于将构造函数选项和传入的options对象进行深度合并，并返回合并后的选项对象
        resolveConstructorOptions(vm.constructor as any),
        options || {},
        // 并传入当前组件实例vm作为上下文，以便在合并过程中能够正确解析props、directives等选项
        vm
      )
    }
    // 只有当前面的条件为 false 时，忽略该行代码的覆盖率检测
    /* istanbul ignore else */
    if (__DEV__) {
      // 如果 __DEV__ 为真（即处于开发环境），则调用 initProxy(vm) 函数来初始化 Vue 实例的代理。
      initProxy(vm)
    } else {
      // 如果 __DEV__ 为假（即处于生产环境），则直接将 vm 赋值给 _renderProxy 属性，从而避免了在生产环境中多余的代理逻辑。
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    // 调用 callHook(vm, 'beforeCreate', undefined, false /* setContext */), 在 Vue 实例创建之前调用 beforeCreate 钩子函数。
    callHook(vm, 'beforeCreate', undefined, false /* setContext */)
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    // 最后再调用 callHook(vm, 'created') 函数，在 Vue 实例创建之后调用 created 钩子函数。
    callHook(vm, 'created')

    /* istanbul ignore if */
    if (__DEV__ && config.performance && mark) {
      // 将当前 Vue 实例的名称（通过 formatComponentName 函数格式化）赋给 _name 属性
      vm._name = formatComponentName(vm, false)
      // 记录名为end的时间戳，表示实例化初始化结束的时间点
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }
    // $options 是一个公共选项对象，它可以包含所有实例初始化参数的属性
    // 这些参数包括但不限于 data、methods、computed、watch、props、components 等等。通过设置这些选项，我们可以配置 Vue 实例的行为和功能
    // 检查 Vue 实例 vm 的 $options 对象中是否包含 el 属性，如果存在则自动调用 vm.$mount() 方法将 Vue 实例挂载到指定的 DOM 元素上
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}

// 基于options参数和父组件的选项来初始化正在创建的内部组件的选项
export function initInternalComponent(
  vm: Component,
  options: InternalComponentOptions
) {
  // 该函数使用Object.create()克隆组件构造函数的选项对象，创建一个新的选项对象，作为组件实例(vm)的选项
  const opts = (vm.$options = Object.create((vm.constructor as any).options))
  // 将选项放在原型链上，如果某个属性需要修改，修改一次就影响所有的实例、如果是动态枚举，就需在每个实例上查找该属性，因此性能提高
  // doing this because it's faster than dynamic enumeration.
  const parentVnode = options._parentVnode
  // 将新组件实例的父组件设置为与options参数的父组件相同
  opts.parent = options.parent
  // 将新组件实例的父虚拟DOM节点设置为与options参数的父虚拟DOM节点相同
  opts._parentVnode = parentVnode
  // 从父虚拟DOM节点中提取各种组件选项，包括propsData、_parentListeners、_renderChildren和_componentTag等
  const vnodeComponentOptions = parentVnode.componentOptions!
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag
  // 如果options参数中定义了render函数，则将其设置为组件实例的render选项，并将staticRenderFns设置为options参数中定义的静态渲染函数
  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}

// 这个函数主要是为了处理组件的继承关系，将父组件的选项和子组件的选项进行合并，并确保子组件中定义的选项能够正确地覆盖父组件中的选项。同时，这个函数还会对被修改或添加的选项进行处理，确保子组件中对选项的修改能够正确地生效
export function resolveConstructorOptions(Ctor: typeof Component) {
  // 获取组件的选项对象，并赋值给 options 变量
  let options = Ctor.options
  if (Ctor.super) {
    // 存在父组件（即存在 Ctor.super），则递归调用 resolveConstructorOptions 函数来获取父组件的选项对象，将其赋值给 superOptions 变量，并获取父组件的缓存选项，将其赋值给 cachedSuperOptions 变量
    const superOptions = resolveConstructorOptions(Ctor.super)
    const cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      // 父组件的选项对象发生了变化，则更新 Ctor.superOptions，并调用 resolveModifiedOptions 函数获取所有被修改的选项（即在子组件中被添加或覆盖的选项），将其合并到 Ctor.extendOptions 中
      Ctor.superOptions = superOptions
      // check if there are any late-modified/attached options (#4976)
      const modifiedOptions = resolveModifiedOptions(Ctor)
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions)
      }
      // 通过 mergeOptions 函数将父组件的选项和子组件的选项合并，得到最终的选项对象，并将其赋值给 options 变量。如果组件定义了 name 属性，则将组件本身注册到 components 对象中
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) {
        options.components[options.name] = Ctor
      }
    }
  }
  return options
}

// 比较一个构造函数的最新选项和之前“封闭”的选项（即最初合并的选项），并返回最新选项中与“封闭”选项不同的部分
function resolveModifiedOptions(
  Ctor: typeof Component
): Record<string, any> | null {
  let modified
  const latest = Ctor.options
  const sealed = Ctor.sealedOptions
  for (const key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) modified = {}
      modified[key] = latest[key]
    }
  }
  return modified
}
```

> Vue 初始化主要就干了几件事情，**`合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等`**
